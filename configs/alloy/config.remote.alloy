// Remote mode: obs stack on remote machine via tunnel
// WAL enabled for buffering during outages, auth headers for security

// Read logs from Docker volume
local.file_match "medicaments_api_logs" {
  path_targets = [{
    __path__ = "/var/log/app/*.log",
    service = "log_collector",
    job = "medicaments-api",
  }]
}

// Parse logs (assuming JSON format with level and path fields)
loki.source.file "medicaments_api_logs" {
  targets    = local.file_match.medicaments_api_logs.targets
  forward_to = [loki.process.parse_json.receiver]
}

// Parse JSON and extract labels
loki.process "parse_json" {
  forward_to = [loki.write.obs.receiver]
  stage.json {
    expressions = {
      timestamp = "time",
      level  = "level",
      path   = "path",
      msg   = "msg",
      status_code = "status_code",
      duration_ms = "duration_ms",
    }
  }

  stage.timestamp {
    source = "timestamp"
    format = "RFC3339Nano"
  }

  // Drop DEBUG logs before storing
  stage.drop {
    source = "level"
    value  = "DEBUG"
  }

  stage.labels {
    values = {
      level  = "level",
      status_code = "",
      threat = "",
    }
  }

  // Security: All probes
  stage.match {
    selector = "{job=\"medicaments-api\"} |~ \"/(\\\\.(git|env|ssh|aws)|wp-admin|phpmyadmin)\""
    
    stage.static_labels {
      values = {
        level  = "WARN",
        threat = "probe",
      }
    }
  }

  // Security: Path traversal
  stage.match {
    selector = "{job=\"medicaments-api\"} |~ \"(\\\\.\\\\./|%2e%2e)\""
    
    stage.static_labels {
      values = {
        level  = "WARN",
        threat = "path-traversal",
      }
    }
  }

  // XSS - these all work reliably with |=
  stage.match {
    selector = "{job=\"medicaments-api\"} |= \"<script\""
    stage.static_labels {
      values = { level = "WARN", threat = "xss" }
    }
  }

  stage.match {
    selector = "{job=\"medicaments-api\"} |= \"javascript:\""
    stage.static_labels {
      values = { level = "WARN", threat = "xss" }
    }
  }

  stage.match {
    selector = "{job=\"medicaments-api\"} |= \"onerror=\""
    stage.static_labels {
      values = { level = "WARN", threat = "xss" }
    }
  }

  stage.match {
    selector = "{job=\"medicaments-api\"} |= \"%3cscript\""
    stage.static_labels {
      values = { level = "WARN", threat = "xss" }
    }
  }

  // Replace INFO with WARN on matched threats
  stage.match {
    selector = "{job=\"medicaments-api\", threat!=\"\"}"
    stage.replace {
      expression = "\"level\":\"(INFO)\""
      replace    = "WARN"
    }
  }
}

// Write to remote Loki with WAL buffering
loki.write "obs" {
  endpoint {
    url = env("LOKI_URL")

    // Cloudflare Access headers (remove headers block if not using Cloudflare)
    headers = {
      "CF-Access-Client-Id"     = env("CF_ACCESS_CLIENT_ID", ""),
      "CF-Access-Client-Secret" = env("CF_ACCESS_CLIENT_SECRET", ""),
    }
  }

  // WAL Buffering for outages
  wal {
    truncate_frequency = "2h"
    max_size_bytes     = 2684354560  # 2.5GB
  }
}

// Scrape app metrics from medicaments-api container
prometheus.scrape "app_metrics" {
  targets = [{
    __address__ = "medicaments-api:9090",
    job         = "medicaments-api",
    instance = "docker-container",
  }]

  forward_to      = [prometheus.relabel.filter_app_metrics.receiver]
  scrape_interval = "30s"
}

// Filter app metrics (keep only HTTP metrics, drop Go internals)
prometheus.relabel "filter_app_metrics"{
  rule {
    source_labels = ["__name__"]
    // Drop Go runtime metrics, keep HTTP metrics
    regex = "go_memstats_heap_idle_bytes|go_memstats_heap_released_bytes|go_memstats_heap_sys_bytes|go_memstats_gc_sys_bytes|go_memstats_stack_inuse_bytes|go_memstats_stack_sys_bytes|go_memstats_mcache_inuse_bytes|go_memstats_mcache_sys_bytes|go_memstats_mspan_inuse_bytes|go_memstats_mspan_sys_bytes|go_memstats_other_sys_bytes|go_memstats_sys_bytes|go_memstats_buck_hash_sys_bytes|go_memstats_next_gc_bytes|go_threads|go_gc_gogc_percent|go_gc_gomemlimit_bytes|go_memstats_frees_total|go_memstats_lookups_total|go_sched_gomaxprocs_threads|go_memstats_last_gc_time_seconds|go_memstats_heap_objects|go_memstats_heap_inuse_bytes|go_gc_duration_seconds_count|go_gc_duration_seconds_sum|go_gc_cycles_automatic_gc_cycles_total|go_gc_cycles_forced_gc_cycles_total|go_info|process_virtual_memory_bytes|process_virtual_memory_max_bytes|promhttp_metric_handler_requests_in_flight|promhttp_metric_handler_requests_total|scrape_samples_post_metric_relabeling|scrape_samples_scraped|scrape_series_added"
    action = "drop"
  }

  forward_to = [prometheus.remote_write.obs.receiver]
}

// Write to remote Prometheus with WAL buffering
prometheus.remote_write "obs" {
  endpoint {
    url = env("PROMETHEUS_URL")

    // Cloudflare Access headers (remove headers block if not using Cloudflare)
    headers = {
      "CF-Access-Client-Id"     = env("CF_ACCESS_CLIENT_ID", ""),
      "CF-Access-Client-Secret" = env("CF_ACCESS_CLIENT_SECRET", ""),
    }

    queue_config {
      capacity             = 10000
      max_samples_per_send = 2000
      batch_send_deadline  = "5s"
      min_backoff          = "30ms"
      max_backoff          = "5s"
    }
  }

  // WAL Buffering for outages
  wal {
    truncate_frequency = "2h"
    max_size_bytes     = 2684354560  # 2.5GB
  }
}
