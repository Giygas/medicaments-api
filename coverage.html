
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>medicamentsfr: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/giygas/medicamentsfr/ip_middleware.go (0.0%)</option>
				
				<option value="file1">github.com/giygas/medicamentsfr/json.go (76.2%)</option>
				
				<option value="file2">github.com/giygas/medicamentsfr/main.go (24.5%)</option>
				
				<option value="file3">github.com/giygas/medicamentsfr/rateLimitHandler.go (68.3%)</option>
				
				<option value="file4">github.com/giygas/medicamentsfr/serveFiles.go (81.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "net"
        "net/http"
        "strings"
)

func getRealClientIP(r *http.Request) string <span class="cov0" title="0">{
        // Check X-Forwarded-For first (most common)
        if xff := r.Header.Get("X-Forwarded-For"); xff != "" </span><span class="cov0" title="0">{
                // X-Forwarded-For can contain multiple IPs: "client, proxy1, proxy2"
                // Take the first one (original client)
                ips := strings.Split(xff, ",")
                clientIP := strings.TrimSpace(ips[0])

                // Validate it's a real IP
                if net.ParseIP(clientIP) != nil </span><span class="cov0" title="0">{
                        return clientIP
                }</span>
        }

        // Fallback to X-Real-IP
        <span class="cov0" title="0">if xri := r.Header.Get("X-Real-IP"); xri != "" </span><span class="cov0" title="0">{
                if net.ParseIP(xri) != nil </span><span class="cov0" title="0">{
                        return xri
                }</span>
        }

        // Last resort: extract from RemoteAddr
        <span class="cov0" title="0">host, _, err := net.SplitHostPort(r.RemoteAddr)
        if err != nil </span><span class="cov0" title="0">{
                return r.RemoteAddr // Return as-is if can't parse
        }</span>
        <span class="cov0" title="0">return host</span>
}

// Middleware to get real IP from nginx
func realIPMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Get the real client IP from nginx headers
                realIP := getRealClientIP(r)

                // Replace the RemoteAddr with the real IP
                r.RemoteAddr = realIP + ":0" // Port doesn't matter for logging

                next.ServeHTTP(w, r)
        }</span>)
}

// Middleware to block direct access to the app
func blockDirectAccessMiddleware(next http.Handler) http.Handler <span class="cov0" title="0">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Check if request is coming through nginx
                if r.Header.Get("X-Forwarded-For") == "" &amp;&amp; r.Header.Get("X-Real-IP") == "" </span><span class="cov0" title="0">{
                        // Direct access without nginx headers
                        host, _, _ := net.SplitHostPort(r.RemoteAddr)

                        // Allow localhost connections (for health checks, etc.)
                        if host != "127.0.0.1" &amp;&amp; host != "::1" &amp;&amp; host != "localhost" </span><span class="cov0" title="0">{
                                http.Error(w, "Direct access not allowed", http.StatusForbidden)
                                return
                        }</span>
                }

                <span class="cov0" title="0">next.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "compress/gzip"
        "encoding/json"
        "log"
        "net/http"
        "time"
)

func respondWithJSON(w http.ResponseWriter, code int, payload interface{}) <span class="cov8" title="1">{
        data, err := json.Marshal(payload)
        if err != nil </span><span class="cov0" title="0">{
                log.Printf("Failed to marshal JSON response: %v", payload)
                w.WriteHeader(500)
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("Last-Modified", time.Now().UTC().Format(http.TimeFormat))
        w.Header().Set("Content-Encoding", "gzip")
        w.WriteHeader(code)
        gz := gzip.NewWriter(w)
        defer gz.Close()
        gz.Write(data)</span>
}

func respondWithError(w http.ResponseWriter, code int, msg string) <span class="cov8" title="1">{
        w.Header().Set("Content-Type", "application/json; charset=utf-8")
        w.Header().Set("Last-Modified", time.Now().UTC().Format(http.TimeFormat))
        w.WriteHeader(code)

        // Create a map to hold the error message
        errorResponse := map[string]string{"error": msg}

        // Marshal the map into JSON
        jsonResponse, err := json.Marshal(errorResponse)
        if err != nil </span><span class="cov0" title="0">{
                // If there's an error, log it and return a generic error message
                http.Error(w, "Internal server error", http.StatusInternalServerError)
                return
        }</span>

        // Write the JSON response to the client
        <span class="cov8" title="1">w.Write(jsonResponse)</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "context"
        "errors"
        "fmt"
        "log"
        "net/http"
        "os"
        "os/signal"
        "path/filepath"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/giygas/medicamentsfr/medicamentsparser"
        "github.com/giygas/medicamentsfr/medicamentsparser/entities"
        "github.com/go-chi/chi/v5"
        "github.com/go-chi/chi/v5/middleware"
        "github.com/go-chi/cors"
        "github.com/go-co-op/gocron"
        "github.com/joho/godotenv"
)

// DataContainer holds all the data with atomic pointers for zero-downtime updates
type DataContainer struct {
        medicaments    atomic.Value // []entities.Medicament
        generiques     atomic.Value // []entities.GeneriqueList
        medicamentsMap atomic.Value // map[int]entities.Medicament
        generiquesMap  atomic.Value // map[int]entities.Generique
        lastUpdated    atomic.Value // time.Time
        updating       atomic.Bool
}

var dataContainer = &amp;DataContainer{}

func scheduleMedicaments() <span class="cov8" title="1">{
        s := gocron.NewScheduler(time.Local)

        // Initial load
        if err := updateData(); err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to perform initial data load:", err)
        }</span>

        // Schedule updates
        <span class="cov0" title="0">_, err := s.Every(1).Days().At("06:00;18:00").Do(func() </span><span class="cov0" title="0">{
                if err := updateData(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Failed to update data: %v", err)
                }</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                log.Fatal("Failed to schedule updates:", err)
        }</span>

        <span class="cov0" title="0">s.StartAsync()

        // Health monitoring
        go func() </span><span class="cov0" title="0">{
                ticker := time.NewTicker(1 * time.Hour)
                defer ticker.Stop()

                for range ticker.C </span><span class="cov0" title="0">{
                        lastUpdate := GetLastUpdated()
                        if time.Since(lastUpdate) &gt; 25*time.Hour </span><span class="cov0" title="0">{
                                log.Println("WARNING: Data hasn't been updated in over 25 hours")
                        }</span>
                }
        }()
}

// Thread-safe getters
func GetMedicaments() []entities.Medicament <span class="cov8" title="1">{
        return dataContainer.medicaments.Load().([]entities.Medicament)
}</span>

func GetGeneriques() []entities.GeneriqueList <span class="cov8" title="1">{
        return dataContainer.generiques.Load().([]entities.GeneriqueList)
}</span>

func GetMedicamentsMap() map[int]entities.Medicament <span class="cov8" title="1">{
        return dataContainer.medicamentsMap.Load().(map[int]entities.Medicament)
}</span>

func GetGeneriquesMap() map[int]entities.Generique <span class="cov8" title="1">{
        return dataContainer.generiquesMap.Load().(map[int]entities.Generique)
}</span>

func GetLastUpdated() time.Time <span class="cov8" title="1">{
        return dataContainer.lastUpdated.Load().(time.Time)
}</span>

func IsUpdating() bool <span class="cov8" title="1">{
        return dataContainer.updating.Load()
}</span>

func updateData() error <span class="cov8" title="1">{
        // Prevent concurrent updates
        if !dataContainer.updating.CompareAndSwap(false, true) </span><span class="cov0" title="0">{
                log.Println("Update already in progress, skipping...")
                return nil
        }</span>
        <span class="cov8" title="1">defer dataContainer.updating.Store(false)

        fmt.Println("Starting database update at:", time.Now())
        start := time.Now()

        // Parse data into temporary variables (not affecting current data)
        newMedicaments := medicamentsparser.ParseAllMedicaments()

        // Create new maps
        newMedicamentsMap := make(map[int]entities.Medicament)
        for i := range newMedicaments </span><span class="cov0" title="0">{
                newMedicamentsMap[newMedicaments[i].Cis] = newMedicaments[i]
        }</span>

        <span class="cov0" title="0">newGeneriques, newGeneriquesMap := medicamentsparser.GeneriquesParser(&amp;newMedicaments, &amp;newMedicamentsMap)

        // Atomic swap (zero downtime replacement)
        dataContainer.medicaments.Store(newMedicaments)
        dataContainer.medicamentsMap.Store(newMedicamentsMap)
        dataContainer.generiques.Store(newGeneriques)
        dataContainer.generiquesMap.Store(newGeneriquesMap)
        dataContainer.lastUpdated.Store(time.Now())

        elapsed := time.Since(start)
        fmt.Printf("Database update completed in %s. Loaded %d medicaments\n",
                elapsed, len(newMedicaments))

        return nil</span>
}

func init() <span class="cov8" title="1">{
        // Initialize stores with empty data
        dataContainer.medicaments.Store(make([]entities.Medicament, 0))
        dataContainer.generiques.Store(make([]entities.GeneriqueList, 0))
        dataContainer.medicamentsMap.Store(make(map[int]entities.Medicament))
        dataContainer.generiquesMap.Store(make(map[int]entities.Generique))
        dataContainer.lastUpdated.Store(time.Time{})

        // Get the working directory and read the env variables
        err := godotenv.Load()
        if err != nil </span><span class="cov0" title="0">{
                // If failed, try loading from executable directory
                ex, err := os.Executable()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">exPath := filepath.Dir(ex)

                err = os.Chdir(exPath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

        }
        <span class="cov8" title="1">go scheduleMedicaments()</span>
}

func main() <span class="cov0" title="0">{

        portString := os.Getenv("PORT")
        if portString == "" </span><span class="cov0" title="0">{
                log.Fatal("PORT is not found in the evironment")
        }</span>
        <span class="cov0" title="0">adressString := os.Getenv("ADRESS")
        if adressString == "" </span><span class="cov0" title="0">{
                adressString = "127.0.0.1" // default to localhost
        }</span>

        <span class="cov0" title="0">router := chi.NewRouter()

        router.Use(middleware.RequestID)
        router.Use(realIPMiddleware)
        router.Use(middleware.Logger)
        router.Use(middleware.Recoverer)
        router.Use(blockDirectAccessMiddleware)

        router.Use(cors.Handler(cors.Options{
                AllowedOrigins:   []string{"*"},
                AllowedMethods:   []string{"GET", "OPTIONS"},
                AllowedHeaders:   []string{"Accept", "Content-Type", "X-CSRF-Token"},
                ExposedHeaders:   []string{"Link"},
                AllowCredentials: false,
                MaxAge:           300,
        }))

        router.Use(rateLimitHandler)

        server := &amp;http.Server{
                Handler:      router,
                Addr:         adressString + ":" + portString,
                ReadTimeout:  15 * time.Second,
                WriteTimeout: 15 * time.Second,
                IdleTimeout:  60 * time.Second,
        }

        // API routes
        router.Get("/database/{pageNumber}", servePagedMedicaments)
        router.Get("/database", serveAllMedicaments)
        router.Get("/medicament/{element}", findMedicament)
        router.Get("/medicament/id/{cis}", findMedicamentById)
        router.Get("/generiques/{libelle}", findGeneriques)
        router.Get("/generiques/group/{groupId}", findGeneriquesByGroupId)
        router.Get("/health", healthCheck)
        router.Get("/debug", debugHeaders)

        // Serve documentation with caching
        router.Get("/", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Set caching headers for HTML
                w.Header().Set("Cache-Control", "public, max-age=3600") // 1 hour
                w.Header().Set("Content-Type", "text/html; charset=utf-8")

                http.ServeFile(w, r, "html/index.html")
        }</span>)

        // Favicon
        <span class="cov0" title="0">router.Get("/favicon.ico", func(w http.ResponseWriter, r *http.Request) </span><span class="cov0" title="0">{
                // Long cache for favicon since it rarely changes
                w.Header().Set("Cache-Control", "public, max-age=31536000") // 1 year
                w.Header().Set("Content-Type", "image/x-icon")

                http.ServeFile(w, r, "html/favicon.ico")
        }</span>)

        // Channel to listen for interrupt signals
        <span class="cov0" title="0">quit := make(chan os.Signal, 1)
        // Register the channel to receive specific signals
        signal.Notify(quit, syscall.SIGINT, syscall.SIGTERM)

        // Start the server in a goroutine
        go func() </span><span class="cov0" title="0">{
                fmt.Printf("Starting server at %s:%v\n", adressString, portString)
                fmt.Printf("Will be accessible via nginx at: http://your-server/medicamentsfr\n")

                if err := server.ListenAndServe(); err != nil &amp;&amp; !errors.Is(err, http.ErrServerClosed) </span><span class="cov0" title="0">{
                        log.Fatalf("Server failed to start: %v\n", err)
                }</span>
        }()

        // Block until a signal is received
        <span class="cov0" title="0">&lt;-quit
        log.Println("Shutting down server...")

        // Create a context with timeout for shutdown
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()

        // Attempt graceful shutdown
        if err := server.Shutdown(ctx); err != nil </span><span class="cov0" title="0">{
                log.Printf("Server forced to shutdown: %v", err)
                // If graceful shutdown fails, force close
                if err := server.Close(); err != nil </span><span class="cov0" title="0">{
                        log.Printf("Server close error: %v", err)
                }</span>
        } else<span class="cov0" title="0"> {
                log.Println("Server exited gracefully")
        }</span>

        // Wait a bit for any ongoing requests to complete
        <span class="cov0" title="0">log.Println("Waiting for ongoing requests to complete...")
        time.Sleep(2 * time.Second)

        log.Println("Server shutdown complete")</span>
}

// TODO: remove this
func debugHeaders(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        headers := map[string]string{
                "RemoteAddr":        r.RemoteAddr,
                "X-Real-IP":         r.Header.Get("X-Real-IP"),
                "X-Forwarded-For":   r.Header.Get("X-Forwarded-For"),
                "X-Forwarded-Proto": r.Header.Get("X-Forwarded-Proto"),
                "Host":              r.Header.Get("Host"),
                "User-Agent":        r.Header.Get("User-Agent"),
        }

        respondWithJSON(w, 200, headers)
}</span>

// Health check endpoint
func healthCheck(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        status := map[string]interface{}{
                "status":           "healthy",
                "medicament_count": len(GetMedicaments()),
                "generique_count":  len(GetGeneriques()),
                "last_updated":     GetLastUpdated(),
                "updating":         IsUpdating(),
        }

        respondWithJSON(w, 200, status)
}</span>
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "net/http"
        "strconv"
        "sync"
        "time"

        "github.com/juju/ratelimit"
)

// Per-client rate limiting
type RateLimiter struct {
        clients map[string]*ratelimit.Bucket
        mu      sync.RWMutex
}

func NewRateLimiter() *RateLimiter <span class="cov8" title="1">{
        return &amp;RateLimiter{
                clients: make(map[string]*ratelimit.Bucket),
        }
}</span>

func (rl *RateLimiter) getBucket(clientIP string) *ratelimit.Bucket <span class="cov8" title="1">{
        rl.mu.RLock()
        bucket, exists := rl.clients[clientIP]
        rl.mu.RUnlock()

        if !exists </span><span class="cov8" title="1">{
                rl.mu.Lock()
                // Double-check pattern
                if bucket, exists = rl.clients[clientIP]; !exists </span><span class="cov8" title="1">{
                        // Create bucket: 30 tokens per second, max 1000 tokens
                        bucket = ratelimit.NewBucketWithRate(30, 1000)
                        rl.clients[clientIP] = bucket
                }</span>
                <span class="cov8" title="1">rl.mu.Unlock()</span>
        }

        <span class="cov8" title="1">return bucket</span>
}

// Clean up old clients periodically
func (rl *RateLimiter) cleanup() <span class="cov8" title="1">{
        ticker := time.NewTicker(1 * time.Hour)
        go func() </span><span class="cov8" title="1">{
                for range ticker.C </span><span class="cov0" title="0">{
                        rl.mu.Lock()
                        // Remove clients that haven't been used recently
                        // TODO: better cleanup
                        for ip, bucket := range rl.clients </span><span class="cov0" title="0">{
                                if bucket.Available() == bucket.Capacity() </span><span class="cov0" title="0">{
                                        delete(rl.clients, ip)
                                }</span>
                        }
                        <span class="cov0" title="0">rl.mu.Unlock()</span>
                }
        }()
}

var globalRateLimiter = NewRateLimiter()

func init() <span class="cov8" title="1">{
        globalRateLimiter.cleanup()
}</span>

func getTokenCost(r *http.Request) int64 <span class="cov8" title="1">{
        switch r.URL.Path </span>{
        case "/database":<span class="cov8" title="1">
                return 500</span> // Higher cost for full database

        // TODO: better bucket costs

        // case "/database/":
        //         return 100 // Medium cost for paged results
        // case "/medicament/":
        //         return 50 // Medium cost for search
        default:<span class="cov8" title="1">
                return 20</span> // Default cost for specific lookups
        }
}

func rateLimitHandler(h http.Handler) http.Handler <span class="cov8" title="1">{
        return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                // Check if the client has a valid cached version of the data
                if r.Header.Get("If-None-Match") != "" || r.Header.Get("If-Modified-Since") != "" </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNotModified)
                        return
                }</span>

                // Get client IP (consider X-Forwarded-For if behind proxy)
                // TODO: ask if this is good if behind nginx server
                <span class="cov8" title="1">clientIP := r.RemoteAddr
                if forwarded := r.Header.Get("X-Forwarded-For"); forwarded != "" </span><span class="cov0" title="0">{
                        clientIP = forwarded
                }</span>

                <span class="cov8" title="1">bucket := globalRateLimiter.getBucket(clientIP)

                // Calculate the token cost for the request
                tokenCost := getTokenCost(r)

                // Check if the client has enough tokens
                if bucket.TakeAvailable(tokenCost) &lt; tokenCost </span><span class="cov0" title="0">{
                        w.Header().Set("X-RateLimit-Limit", "30")
                        w.Header().Set("X-RateLimit-Remaining", "0")
                        w.Header().Set("Retry-After", "60")
                        http.Error(w, "Rate limit exceeded. Please try again later.", http.StatusTooManyRequests)
                        return
                }</span>

                // Add rate limit headers
                <span class="cov8" title="1">w.Header().Set("X-RateLimit-Limit", "30")
                w.Header().Set("X-RateLimit-Remaining", strconv.FormatInt(bucket.Available(), 10))

                // Serve the request
                h.ServeHTTP(w, r)</span>
        })
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "net/http"
        "regexp"
        "strconv"
        "time"

        "github.com/giygas/medicamentsfr/medicamentsparser/entities"
        "github.com/go-chi/chi/v5"
)

// Helper function to check cached versions
func checkCachedVersion(w http.ResponseWriter, r *http.Request, lastUpdated time.Time) bool <span class="cov8" title="1">{
        // Check If-Modified-Since
        if ims := r.Header.Get("If-Modified-Since"); ims != "" </span><span class="cov0" title="0">{
                if t, err := time.Parse(http.TimeFormat, ims); err == nil </span><span class="cov0" title="0">{
                        if !lastUpdated.After(t) </span><span class="cov0" title="0">{
                                w.WriteHeader(http.StatusNotModified)
                                return true
                        }</span>
                }
        }
        // Check If-None-Match (ETag)
        <span class="cov8" title="1">if inm := r.Header.Get("If-None-Match"); inm != "" </span><span class="cov0" title="0">{
                etag := `"` + strconv.FormatInt(lastUpdated.Unix(), 10) + `"`
                if inm == etag </span><span class="cov0" title="0">{
                        w.WriteHeader(http.StatusNotModified)
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

func serveAllMedicaments(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        medicaments := GetMedicaments()
        lastUpdated := GetLastUpdated()

        // Set caching headers
        w.Header().Set("Cache-Control", "public, max-age=21600") // 6 hours
        w.Header().Set("Last-Modified", lastUpdated.UTC().Format(http.TimeFormat))
        w.Header().Set("ETag", `"`+strconv.FormatInt(lastUpdated.Unix(), 10)+`"`)

        // Check if client has cached version
        if checkCachedVersion(w, r, lastUpdated) </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">respondWithJSON(w, 200, medicaments)</span>
}

func servePagedMedicaments(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        page, err := strconv.Atoi(chi.URLParam(r, "pageNumber"))

        if err != nil || page &lt; 1 </span><span class="cov8" title="1">{
                respondWithError(w, 400, "Invalid page number")

                return
        }</span>

        <span class="cov8" title="1">medicaments := GetMedicaments()
        lastUpdated := GetLastUpdated()

        // Set caching headers
        w.Header().Set("Cache-Control", "public, max-age=21600")
        w.Header().Set("Last-Modified", lastUpdated.UTC().Format(http.TimeFormat))

        totalItems := len(medicaments)
        pageSize := 10
        maxPage := (totalItems + pageSize - 1) / pageSize // Ceiling division

        if page &gt; maxPage </span><span class="cov8" title="1">{
                respondWithError(w, 404, "Maximum page possible is: "+strconv.Itoa(maxPage))
                return
        }</span>

        <span class="cov8" title="1">start := (page - 1) * pageSize
        end := start + pageSize
        if end &gt; totalItems </span><span class="cov8" title="1">{
                end = totalItems
        }</span>

        <span class="cov8" title="1">result := struct {
                Data       []entities.Medicament `json:"data"`
                Page       int                   `json:"page"`
                PageSize   int                   `json:"pageSize"`
                TotalItems int                   `json:"totalItems"`
                MaxPage    int                   `json:"maxPage"`
        }{
                Data:       medicaments[start:end],
                Page:       page,
                PageSize:   pageSize,
                TotalItems: totalItems,
                MaxPage:    maxPage,
        }

        respondWithJSON(w, 200, result)</span>
}

func findMedicament(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userPattern := chi.URLParam(r, "element")
        if len(userPattern) &lt; 2 </span><span class="cov0" title="0">{
                respondWithError(w, 400, "Search term must be at least 2 characters")
                return
        }</span>

        <span class="cov8" title="1">pattern, err := regexp.Compile(`(?i)` + regexp.QuoteMeta(userPattern))
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, 400, "Invalid search pattern")
                return
        }</span>

        <span class="cov8" title="1">medicaments := GetMedicaments()
        var matchingMedicaments []entities.Medicament

        for _, med := range medicaments </span><span class="cov8" title="1">{
                if pattern.MatchString(med.Denomination) </span><span class="cov8" title="1">{
                        matchingMedicaments = append(matchingMedicaments, med)
                }</span>
        }

        <span class="cov8" title="1">if len(matchingMedicaments) == 0 </span><span class="cov8" title="1">{
                respondWithError(w, 404, "No medicaments found matching the search term")
                return
        }</span>

        // Set shorter cache for search results
        <span class="cov8" title="1">w.Header().Set("Cache-Control", "public, max-age=3600") // 1 hour

        result := struct {
                Results []entities.Medicament `json:"results"`
                Count   int                   `json:"count"`
                // Limited bool                  `json:"limited"`   -- In case of limiting results
        }{
                Results: matchingMedicaments,
                Count:   len(matchingMedicaments),
                // Limited: len(matchingMedicaments) == maxResults,
        }

        respondWithJSON(w, 200, result)</span>

}

func findMedicamentById(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        cis, err := strconv.Atoi(chi.URLParam(r, "cis"))
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, 400, "Invalid CIS number")
                return
        }</span>

        <span class="cov8" title="1">medicamentsMap := GetMedicamentsMap()
        medicament, exists := medicamentsMap[cis]

        if !exists </span><span class="cov8" title="1">{
                respondWithError(w, 404, "Medicament not found")
                return
        }</span>

        // Set caching headers for individual medicaments
        <span class="cov8" title="1">lastUpdated := GetLastUpdated()
        w.Header().Set("Cache-Control", "public, max-age=43200") // 12 hours
        w.Header().Set("Last-Modified", lastUpdated.UTC().Format(http.TimeFormat))

        respondWithJSON(w, 200, medicament)</span>
}

func findGeneriques(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        userPattern := chi.URLParam(r, "libelle")
        if len(userPattern) &lt; 2 </span><span class="cov0" title="0">{
                respondWithError(w, 400, "Search term must be at least 2 characters")
                return
        }</span>

        <span class="cov8" title="1">pattern, err := regexp.Compile(`(?i)` + regexp.QuoteMeta(userPattern))
        if err != nil </span><span class="cov0" title="0">{
                respondWithError(w, 400, "Invalid search pattern")
                return
        }</span>

        <span class="cov8" title="1">generiques := GetGeneriques()
        var matchingGeneriques []entities.GeneriqueList

        for _, gen := range generiques </span><span class="cov8" title="1">{
                if pattern.MatchString(gen.Libelle) </span><span class="cov8" title="1">{
                        matchingGeneriques = append(matchingGeneriques, gen)
                }</span>
        }

        <span class="cov8" title="1">if len(matchingGeneriques) == 0 </span><span class="cov8" title="1">{
                respondWithError(w, 404, "No generiques found matching the search term")
                return
        }</span>

        <span class="cov8" title="1">w.Header().Set("Cache-Control", "public, max-age=3600")
        respondWithJSON(w, 200, matchingGeneriques)</span>

}

func findGeneriquesByGroupId(w http.ResponseWriter, r *http.Request) <span class="cov8" title="1">{
        groupId, err := strconv.Atoi(chi.URLParam(r, "groupId"))
        if err != nil </span><span class="cov8" title="1">{
                respondWithError(w, 400, "Invalid group ID")
                return
        }</span>

        <span class="cov8" title="1">generiquesMap := GetGeneriquesMap()
        generique, exists := generiquesMap[groupId]
        if !exists </span><span class="cov8" title="1">{
                respondWithError(w, 404, "Generique group not found")
                return
        }</span>

        <span class="cov8" title="1">lastUpdated := GetLastUpdated()
        w.Header().Set("Cache-Control", "public, max-age=43200")
        w.Header().Set("Last-Modified", lastUpdated.UTC().Format(http.TimeFormat))

        respondWithJSON(w, 200, generique)</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
