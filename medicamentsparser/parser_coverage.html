
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>medicamentsparser: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/giygas/medicaments-api/medicamentsparser/downloader.go (76.2%)</option>
				
				<option value="file1">github.com/giygas/medicaments-api/medicamentsparser/fileReader.go (30.0%)</option>
				
				<option value="file2">github.com/giygas/medicaments-api/medicamentsparser/generiquesParser.go (75.6%)</option>
				
				<option value="file3">github.com/giygas/medicaments-api/medicamentsparser/medicamentsParser.go (79.8%)</option>
				
				<option value="file4">github.com/giygas/medicaments-api/medicamentsparser/tsvConverter.go (85.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Package medicamentsparser provides functionality for downloading and parsing medicament data from external sources.
package medicamentsparser

import (
        "bufio"
        "fmt"
        "net/http"
        "os"
        "path/filepath"
        "sync"

        "github.com/giygas/medicaments-api/logging"
        "golang.org/x/text/encoding/charmap"
)

func downloadAndParseFile(filepath string, url string) error <span class="cov8" title="1">{

        filepath = "files/" + filepath + ".txt"
        response, err := http.Get(url)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to download %s: %w", url, err)
        }</span>
        <span class="cov8" title="1">defer response.Body.Close()

        outFile, err := os.Create(filepath)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create file %s: %w", filepath, err)
        }</span>

        <span class="cov8" title="1">defer outFile.Close()
        reader := charmap.Windows1252.NewDecoder().Reader(response.Body)
        scanner := bufio.NewScanner(reader)

        for scanner.Scan() </span><span class="cov8" title="1">{
                _, err = fmt.Fprintln(outFile, scanner.Text())
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("failed to write to file %s: %w", filepath, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Download all files concurrently
func downloadAndParseAll() error <span class="cov8" title="1">{

        //Files to download
        var files = map[string]string{
                "Specialites":   "https://base-donnees-publique.medicaments.gouv.fr/download/file/CIS_bdpm.txt",
                "Presentations": "https://base-donnees-publique.medicaments.gouv.fr/download/file/CIS_CIP_bdpm.txt",
                "Compositions":  "https://base-donnees-publique.medicaments.gouv.fr/download/file/CIS_COMPO_bdpm.txt",
                "Generiques":    "https://base-donnees-publique.medicaments.gouv.fr/download/file/CIS_GENER_bdpm.txt",
                "Conditions":    "https://base-donnees-publique.medicaments.gouv.fr/download/file/CIS_CPD_bdpm.txt",
        }

        //Create the files directory if it doesn't exists
        filePath := filepath.Join(".", "files")
        err := os.MkdirAll(filePath, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create files directory: %w", err)
        }</span>
        <span class="cov8" title="1">filePath = filepath.Join(".", "src")
        err = os.MkdirAll(filePath, os.ModePerm)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to create src directory: %w", err)
        }</span>

        <span class="cov8" title="1">var wg sync.WaitGroup
        var mu sync.Mutex
        var errors []error

        for fileName, url := range files </span><span class="cov8" title="1">{
                wg.Add(1)

                go func(file string, url string) </span><span class="cov8" title="1">{
                        defer wg.Done()
                        if err := downloadAndParseFile(file, url); err != nil </span><span class="cov0" title="0">{
                                mu.Lock()
                                errors = append(errors, err)
                                mu.Unlock()
                        }</span>
                }(fileName, url)

        }
        <span class="cov8" title="1">wg.Wait()

        if len(errors) &gt; 0 </span><span class="cov0" title="0">{
                logging.Error("Download errors occurred", "errors", errors)
                return fmt.Errorf("download errors: %v", errors)
        }</span>

        <span class="cov8" title="1">logging.Info("Files downloaded and parsed successfully")

        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package medicamentsparser

import (
        "encoding/json"
        "fmt"
        "os"

        "github.com/giygas/medicaments-api/medicamentsparser/entities"
)

func specialitesFileToJSON() ([]entities.Specialite, error) <span class="cov8" title="1">{
        fileData, err := os.ReadFile("src/Specialites.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading Specialites.json: %w", err)
        }</span>

        <span class="cov8" title="1">var specialites []entities.Specialite
        err = json.Unmarshal(fileData, &amp;specialites)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding Specialites JSON: %w", err)
        }</span>

        //Returns the full Specialites json as a slice of Specialites
        <span class="cov8" title="1">return specialites, nil</span>
}

func compositionFileToJSON() ([]entities.Composition, error) <span class="cov0" title="0">{
        fileData, err := os.ReadFile("src/Compositions.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading Compositions.json: %w", err)
        }</span>

        <span class="cov0" title="0">var data []entities.Composition
        err = json.Unmarshal(fileData, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding Compositions JSON: %w", err)
        }</span>

        //Returns the full Composition json as a slice of Composition
        <span class="cov0" title="0">return data, nil</span>
}

func conditionFileToJSON() ([]entities.Condition, error) <span class="cov0" title="0">{
        fileData, err := os.ReadFile("src/Conditions.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading Conditions.json: %w", err)
        }</span>

        <span class="cov0" title="0">var data []entities.Condition
        err = json.Unmarshal(fileData, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding Conditions JSON: %w", err)
        }</span>

        //Returns the full Condition json as a slice of Condition
        <span class="cov0" title="0">return data, nil</span>
}

func generiqueFileToJSON() (map[string][]int, error) <span class="cov8" title="1">{
        fileData, err := os.ReadFile("src/Generiques.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading Generiques.json: %w", err)
        }</span>

        <span class="cov8" title="1">var data map[string][]int

        err = json.Unmarshal(fileData, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding Generiques JSON: %w", err)
        }</span>

        //Returns the full Generique json as a slice of Generique
        <span class="cov8" title="1">return data, nil</span>
}

func presentationFileToJSON() ([]entities.Presentation, error) <span class="cov0" title="0">{
        fileData, err := os.ReadFile("src/Presentations.json")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error reading Presentations.json: %w", err)
        }</span>

        <span class="cov0" title="0">var data []entities.Presentation
        err = json.Unmarshal(fileData, &amp;data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error decoding Presentations JSON: %w", err)
        }</span>

        //Returns the full Presentation json as a slice of Presentation
        <span class="cov0" title="0">return data, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package medicamentsparser

import (
        "encoding/json"
        "fmt"
        "os"
        "strconv"

        "github.com/giygas/medicaments-api/logging"
        "github.com/giygas/medicaments-api/medicamentsparser/entities"
)

var medsType map[int]string

func GeneriquesParser(medicaments *[]entities.Medicament, mMap *map[int]entities.Medicament) ([]entities.GeneriqueList, map[int]entities.Generique, error) <span class="cov8" title="1">{

        var err error

        // allGeneriques: []Generique
        allGeneriques, err := makeGeneriques(nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to parse generiques: %w", err)
        }</span>

        // Create a map of all the generiques to reduce algorithm complexity
        <span class="cov8" title="1">generiquesMap := make(map[int]entities.Generique)
        for i := range allGeneriques </span><span class="cov8" title="1">{
                generiquesMap[allGeneriques[i].Group] = allGeneriques[i]
        }</span>

        // generiques file: [groupid]:[]cis of medicaments in the same group
        <span class="cov8" title="1">generiquesFile, err := generiqueFileToJSON()
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("Failed to read generiques file", "error", err)
                return nil, nil, fmt.Errorf("failed to read generiques file: %w", err)
        }</span>

        // The medsType is a map where the key are the medicament cis and the value is the
        // type of generique
        <span class="cov8" title="1">medsType, err = createMedicamentGeneriqueType()
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, fmt.Errorf("failed to create medicament generique type mapping: %w", err)
        }</span>

        <span class="cov8" title="1">var generiques []entities.GeneriqueList

        for i, v := range generiquesFile </span><span class="cov8" title="1">{

                // Convert the string index to integer
                groupInt, convErr := strconv.Atoi(i)
                if convErr != nil </span><span class="cov0" title="0">{
                        logging.Error("An error occurred converting the generiques group to integer", "error", convErr, "group_id", i)
                        continue</span>
                }

                <span class="cov8" title="1">current := entities.GeneriqueList{
                        GroupID:     groupInt,
                        Libelle:     generiquesMap[groupInt].Libelle,
                        Medicaments: getMedicamentsInArray(v, mMap),
                }

                generiques = append(generiques, current)</span>
        }

        // Write debug file
        <span class="cov8" title="1">marshalledGeneriques, err := json.MarshalIndent(generiques, "", " ")
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("Error marshalling generiques", "error", err)
        }</span> else<span class="cov8" title="1"> {
                if writeErr := os.WriteFile("src/GeneriquesFull.json", marshalledGeneriques, 0644); writeErr != nil </span><span class="cov0" title="0">{
                        logging.Error("Error writing GeneriquesFull.json", "error", writeErr)
                }</span>
        }

        <span class="cov8" title="1">fmt.Println("Generiques parsing completed", "count", len(generiques))
        return generiques, generiquesMap, nil</span>
}

func createGeneriqueComposition(medicamentComposition *[]entities.Composition) []entities.GeneriqueComposition <span class="cov8" title="1">{
        var compositions []entities.GeneriqueComposition
        for _, v := range *medicamentComposition </span><span class="cov0" title="0">{
                compo := entities.GeneriqueComposition{
                        ElementParmaceutique:  v.ElementParmaceutique,
                        DenominationSubstance: v.DenominationSubstance,
                        Dosage:                v.Dosage,
                }
                compositions = append(compositions, compo)
        }</span>
        <span class="cov8" title="1">return compositions</span>
}

func getMedicamentsInArray(medicamentsIds []int, medicamentMap *map[int]entities.Medicament) []entities.GeneriqueMedicament <span class="cov8" title="1">{
        var medicamentsArray []entities.GeneriqueMedicament

        for _, v := range medicamentsIds </span><span class="cov8" title="1">{
                if medicament, ok := (*medicamentMap)[v]; ok </span><span class="cov8" title="1">{
                        generiqueComposition := createGeneriqueComposition(&amp;medicament.Composition)
                        generiqueMed := entities.GeneriqueMedicament{
                                Cis:                 medicament.Cis,
                                Denomination:        medicament.Denomination,
                                FormePharmaceutique: medicament.FormePharmaceutique,
                                Type:                medsType[medicament.Cis],
                                Composition:         generiqueComposition,
                        }
                        medicamentsArray = append(medicamentsArray, generiqueMed)
                }</span>
        }

        <span class="cov8" title="1">return medicamentsArray</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Package medicamentsparser provides functionality for downloading and parsing medicament data from external sources.
package medicamentsparser

import (
        "encoding/json"
        "fmt"
        "os"
        "sync"

        "github.com/giygas/medicaments-api/logging"
        "github.com/giygas/medicaments-api/medicamentsparser/entities"
)

func validateMedicamenti(m *entities.Medicament) error <span class="cov8" title="1">{
        if m.Cis &lt;= 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("invalid CIS: %d", m.Cis)
        }</span>
        <span class="cov8" title="1">if m.Denomination == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing denomination")
        }</span>
        <span class="cov8" title="1">if m.FormePharmaceutique == "" </span><span class="cov0" title="0">{
                return fmt.Errorf("missing forme pharmaceutique")
        }</span>
        // Add more checks as needed
        <span class="cov8" title="1">return nil</span>
}

func ParseAllMedicaments() ([]entities.Medicament, error) <span class="cov8" title="1">{

        // Download the neccesary files from https://base-donnees-publique.medicaments.gouv.fr/telechargement
        downloadAndParseAll()

        //Make all the json files concurrently
        var wg sync.WaitGroup
        wg.Add(5)

        conditionsChan := make(chan []entities.Condition)
        presentationsChan := make(chan []entities.Presentation)
        specialitesChan := make(chan []entities.Specialite)
        generiquesChan := make(chan []entities.Generique)
        compositionsChan := make(chan []entities.Composition)
        errorChan := make(chan error, 5)

        go func() </span><span class="cov8" title="1">{
                result, err := makeConditions(&amp;wg)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Error("Failed to parse conditions", "error", err)
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">conditionsChan &lt;- result</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                result, err := makePresentations(&amp;wg)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Error("Failed to parse presentations", "error", err)
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">presentationsChan &lt;- result</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                result, err := makeSpecialites(&amp;wg)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Error("Failed to parse specialites", "error", err)
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">specialitesChan &lt;- result</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                result, err := makeGeneriques(&amp;wg)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Error("Failed to parse generiques", "error", err)
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">generiquesChan &lt;- result</span>
        }()

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                result, err := makeCompositions(&amp;wg)
                if err != nil </span><span class="cov0" title="0">{
                        logging.Error("Failed to parse compositions", "error", err)
                        errorChan &lt;- err
                        return
                }</span>
                <span class="cov8" title="1">compositionsChan &lt;- result</span>
        }()

        <span class="cov8" title="1">wg.Wait()

        conditions := &lt;-conditionsChan
        presentations := &lt;-presentationsChan
        specialites := &lt;-specialitesChan
        generiques := &lt;-generiquesChan
        compositions := &lt;-compositionsChan

        fmt.Printf("Number of conditions to process: %d\n", len(conditions))
        fmt.Printf("Number of presentations to process: %d\n", len(presentations))
        fmt.Printf("Number of generiques to process: %d\n", len(generiques))
        fmt.Printf("Number of specialites to process: %d\n", len(specialites))

        conditionsChan = nil
        presentationsChan = nil
        specialitesChan = nil
        generiquesChan = nil
        compositionsChan = nil

        // Make lookup maps (this is s O(n) task, but it makes possible searching as O(1))
        compositionsMap := make(map[int][]entities.Composition)
        for _, comp := range compositions </span><span class="cov8" title="1">{
                compositionsMap[comp.Cis] = append(compositionsMap[comp.Cis], comp)
        }</span>

        <span class="cov8" title="1">generiquesMap := make(map[int][]entities.Generique)
        for _, gen := range generiques </span><span class="cov8" title="1">{
                generiquesMap[gen.Cis] = append(generiquesMap[gen.Cis], gen)
        }</span>

        <span class="cov8" title="1">presentationsMap := make(map[int][]entities.Presentation)
        for _, pres := range presentations </span><span class="cov8" title="1">{
                presentationsMap[pres.Cis] = append(presentationsMap[pres.Cis], pres)
        }</span>

        <span class="cov8" title="1">conditionsMap := make(map[int][]string)
        for _, cond := range conditions </span><span class="cov8" title="1">{
                conditionsMap[cond.Cis] = append(conditionsMap[cond.Cis], cond.Condition)
        }</span>

        <span class="cov8" title="1">medicamentsSlice := make([]entities.Medicament, 0, len(specialites))

        for _, med := range specialites </span><span class="cov8" title="1">{

                medicament := new(entities.Medicament)

                medicament.Cis = med.Cis
                medicament.Denomination = med.Denomination
                medicament.FormePharmaceutique = med.FormePharmaceutique
                medicament.VoiesAdministration = med.VoiesAdministration
                medicament.StatusAutorisation = med.StatusAutorisation
                medicament.TypeProcedure = med.TypeProcedure
                medicament.EtatComercialisation = med.EtatComercialisation
                medicament.DateAMM = med.DateAMM
                medicament.Titulaire = med.Titulaire
                medicament.SurveillanceRenforcee = med.SurveillanceRenforcee

                // Using map for O(1) lookup
                // Get all the compositions of this medicament
                if comps, exists := compositionsMap[med.Cis]; exists </span><span class="cov8" title="1">{
                        medicament.Composition = comps
                }</span>

                // Get all the generiques of this medicament
                <span class="cov8" title="1">if gen, exists := generiquesMap[med.Cis]; exists </span><span class="cov8" title="1">{
                        medicament.Generiques = gen
                }</span>

                // Get all the presentations of this medicament
                <span class="cov8" title="1">if pres, exists := presentationsMap[med.Cis]; exists </span><span class="cov8" title="1">{
                        medicament.Presentation = pres
                }</span>

                // Get the conditions of this medicament
                <span class="cov8" title="1">if cond, exists := conditionsMap[med.Cis]; exists </span><span class="cov8" title="1">{
                        medicament.Conditions = cond
                }</span>

                // Validate the medicament structure
                <span class="cov8" title="1">if err := validateMedicamenti(medicament); err != nil </span><span class="cov0" title="0">{
                        logging.Warn("Skipping invalid medicament: ", "error", err, "cis", med.Cis)
                        continue</span>
                }

                <span class="cov8" title="1">medicamentsSlice = append(medicamentsSlice, *medicament)</span>

        }

        <span class="cov8" title="1">logging.Info("All medicaments parsed successfully")
        jsonMedicament, err := json.MarshalIndent(medicamentsSlice, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("Error marshalling medicaments", "error", err)
                return nil, err
        }</span>

        <span class="cov8" title="1">err = os.WriteFile("src/Medicaments.json", jsonMedicament, 0644)
        if err != nil </span><span class="cov0" title="0">{
                logging.Error("Error writing Medicaments.json", "error", err)
                return nil, err
        }</span>
        <span class="cov8" title="1">os.Stdout.Sync()

        conditions = nil
        presentations = nil
        specialites = nil
        generiques = nil
        compositions = nil

        return medicamentsSlice, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package medicamentsparser

import (
        "bufio"
        "encoding/json"
        "fmt"
        "math"
        "os"
        "strconv"
        "strings"
        "sync"

        "github.com/giygas/medicaments-api/medicamentsparser/entities"
)

func makePresentations(wg *sync.WaitGroup) ([]entities.Presentation, error) <span class="cov8" title="1">{
        if wg != nil </span><span class="cov8" title="1">{
                defer wg.Done()
        }</span>

        <span class="cov8" title="1">tsvFile, err := os.Open("files/Presentations.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open Presentations.txt: %w", err)
        }</span>
        <span class="cov8" title="1">defer tsvFile.Close()

        scanner := bufio.NewScanner(tsvFile)

        var jsonRecords []entities.Presentation

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                fields := strings.Split(line, "\t")

                cis, err := strconv.Atoi(fields[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cis value '%s': %w", fields[0], err)
                }</span>

                <span class="cov8" title="1">cip7, err := strconv.Atoi(fields[1])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cip7 value '%s': %w", fields[1], err)
                }</span>

                <span class="cov8" title="1">cip13, err := strconv.Atoi(fields[6])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cip13 value '%s': %w", fields[6], err)
                }</span>

                // Because the downloaded database has commas as thousands and decimal separators,
                // all the commas have to be removed except for the last one
                // If the prix is empty, 0.0 will we added in the prix section
                <span class="cov8" title="1">var prix float32

                if fields[9] != "" </span><span class="cov8" title="1">{

                        // Count the number of commas
                        numCommas := strings.Count(fields[9], ",")

                        // If there's more than one comma, replace all but the last one
                        if numCommas &gt; 1 </span><span class="cov8" title="1">{
                                fields[9] = strings.Replace(fields[9], ",", "", numCommas-1)
                        }</span>

                        // Replace the last comma with a period
                        <span class="cov8" title="1">p, err := strconv.ParseFloat(strings.Replace(fields[9], ",", ".", -1), 32)

                        if err != nil </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("invalid price value '%s': %w", fields[9], err)
                        }</span>
                        <span class="cov8" title="1">p = math.Trunc(p*100) / 100

                        prix = float32(p)</span>
                } else<span class="cov8" title="1"> {
                        prix = 0.0
                }</span>

                <span class="cov8" title="1">record := entities.Presentation{
                        Cis:                  cis,
                        Cip7:                 cip7,
                        Libelle:              fields[2],
                        StatusAdministratif:  fields[3],
                        EtatComercialisation: fields[4],
                        DateDeclaration:      fields[5],
                        Cip13:                cip13,
                        Agreement:            fields[7],
                        TauxRemboursement:    fields[8],
                        Prix:                 prix,
                }

                jsonRecords = append(jsonRecords, record)</span>
        }

        <span class="cov8" title="1">fmt.Println("Presentations file conversion completed", "records_count", len(jsonRecords))
        return jsonRecords, nil</span>
}

func makeGeneriques(wg *sync.WaitGroup) ([]entities.Generique, error) <span class="cov8" title="1">{

        if wg != nil </span><span class="cov8" title="1">{
                defer wg.Done()
        }</span>

        <span class="cov8" title="1">tsvFile, err := os.Open("files/Generiques.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open generiques file: %w", err)
        }</span>
        <span class="cov8" title="1">defer tsvFile.Close()

        scanner := bufio.NewScanner(tsvFile)

        // Create the variables to use in the loop
        var jsonRecords []entities.Generique

        // Use a map for creating the generiques list
        generiquesList := make(map[int][]int)

        lineCount := 0
        for scanner.Scan() </span><span class="cov8" title="1">{
                lineCount++
                line := scanner.Text()
                fields := strings.Split(line, "\t")

                if len(fields) &lt; 4 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">cis, cisError := strconv.Atoi(fields[2])
                if cisError != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid CIS value '%s' at line %d: %w", fields[2], lineCount, cisError)
                }</span>

                <span class="cov8" title="1">group, groupErr := strconv.Atoi(fields[0])
                if groupErr != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid group value '%s' at line %d: %w", fields[0], lineCount, groupErr)
                }</span>

                <span class="cov8" title="1">var generiqueType string

                switch fields[3] </span>{
                case "0":<span class="cov8" title="1">
                        generiqueType = "Princeps"</span>
                case "1":<span class="cov8" title="1">
                        generiqueType = "Générique"</span>
                case "2":<span class="cov8" title="1">
                        generiqueType = "Génériques par complémentarité posologique"</span>
                case "3":<span class="cov0" title="0">
                        generiqueType = "Générique substitutable"</span>
                }

                <span class="cov8" title="1">record := entities.Generique{
                        Cis:     cis,
                        Group:   group,
                        Libelle: fields[1],
                        Type:    generiqueType,
                }

                jsonRecords = append(jsonRecords, record)

                // Append to the array of generiques
                if cis != 0 </span><span class="cov8" title="1">{
                        generiquesList[group] = append(generiquesList[group], cis)
                }</span>
        }

        <span class="cov8" title="1">jsonGeneriques, err := json.MarshalIndent(generiquesList, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("error marshalling generiques: %w", err)
        }</span>

        <span class="cov8" title="1">if wg != nil </span><span class="cov8" title="1">{
                _ = os.WriteFile("src/Generiques.json", jsonGeneriques, 0644)
        }</span>

        <span class="cov8" title="1">fmt.Println("Generiques file conversion completed", "records_count", len(jsonRecords))
        return jsonRecords, nil</span>
}

func makeCompositions(wg *sync.WaitGroup) ([]entities.Composition, error) <span class="cov8" title="1">{
        if wg != nil </span><span class="cov8" title="1">{
                defer wg.Done()
        }</span>

        <span class="cov8" title="1">tsvFile, err := os.Open("files/Compositions.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open compositions file: %w", err)
        }</span>
        <span class="cov8" title="1">defer tsvFile.Close()

        scanner := bufio.NewScanner(tsvFile)

        var jsonRecords []entities.Composition

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                fields := strings.Split(line, "\t")

                cis, err := strconv.Atoi(fields[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cis value '%s': %w", fields[0], err)
                }</span>

                <span class="cov8" title="1">codeS, err := strconv.Atoi(fields[2])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid codeSubstance value '%s': %w", fields[2], err)
                }</span>

                <span class="cov8" title="1">record := entities.Composition{
                        Cis:                   cis,
                        ElementParmaceutique:  fields[1],
                        CodeSubstance:         codeS,
                        DenominationSubstance: fields[3],
                        Dosage:                fields[4],
                        ReferenceDosage:       fields[5],
                        NatureComposant:       fields[6],
                }

                jsonRecords = append(jsonRecords, record)</span>
        }

        <span class="cov8" title="1">fmt.Println("Compositions file conversion completed", "records_count", len(jsonRecords))
        return jsonRecords, nil</span>
}

func makeSpecialites(wg *sync.WaitGroup) ([]entities.Specialite, error) <span class="cov8" title="1">{
        if wg != nil </span><span class="cov8" title="1">{
                defer wg.Done()
        }</span>

        <span class="cov8" title="1">tsvFile, err := os.Open("files/Specialites.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open Specialites.txt: %w", err)
        }</span>
        <span class="cov8" title="1">defer tsvFile.Close()

        scanner := bufio.NewScanner(tsvFile)

        var jsonRecords []entities.Specialite

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                fields := strings.Split(line, "\t")

                cis, err := strconv.Atoi(fields[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cis value '%s': %w", fields[0], err)
                }</span>

                <span class="cov8" title="1">record := entities.Specialite{
                        Cis:                   cis,
                        Denomination:          fields[1],
                        FormePharmaceutique:   fields[2],
                        VoiesAdministration:   strings.Split(fields[3], ";"),
                        StatusAutorisation:    fields[4],
                        TypeProcedure:         fields[5],
                        EtatComercialisation:  fields[6],
                        DateAMM:               fields[7],
                        Titulaire:             strings.TrimLeft(fields[10], " "),
                        SurveillanceRenforcee: fields[11],
                }

                jsonRecords = append(jsonRecords, record)</span>
        }

        <span class="cov8" title="1">fmt.Println("Specialites file conversion completed", "records_count", len(jsonRecords))
        return jsonRecords, nil</span>
}

func makeConditions(wg *sync.WaitGroup) ([]entities.Condition, error) <span class="cov8" title="1">{
        if wg != nil </span><span class="cov8" title="1">{
                defer wg.Done()
        }</span>

        <span class="cov8" title="1">tsvFile, err := os.Open("files/Conditions.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open Conditions.txt: %w", err)
        }</span>
        <span class="cov8" title="1">defer tsvFile.Close()

        scanner := bufio.NewScanner(tsvFile)

        var jsonRecords []entities.Condition

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                fields := strings.Split(line, "\t")

                // For some weird reason, the csv file from the site has some empty lines between the data
                if len(line) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">cis, err := strconv.Atoi(fields[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cis value '%s': %w", fields[0], err)
                }</span>

                <span class="cov8" title="1">record := entities.Condition{
                        Cis:       cis,
                        Condition: fields[1],
                }

                jsonRecords = append(jsonRecords, record)</span>
        }

        <span class="cov8" title="1">fmt.Println("Conditions file conversion completed", "records_count", len(jsonRecords))
        return jsonRecords, nil</span>
}

// Creates a mapping where the key is the medicament cis and the value is the type of generique of the medicament
// Returns a map where key:cis and value:typeOfGenerique
func createMedicamentGeneriqueType() (map[int]string, error) <span class="cov8" title="1">{
        medsType := make(map[int]string)

        tsvFile, err := os.Open("files/Generiques.txt")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to open generique file: %w", err)
        }</span>
        <span class="cov8" title="1">defer tsvFile.Close()

        scanner := bufio.NewScanner(tsvFile)

        for scanner.Scan() </span><span class="cov8" title="1">{
                line := scanner.Text()
                fields := strings.Split(line, "\t")

                cis, err := strconv.Atoi(fields[2])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid cis value in Generiques file '%s': %w", fields[2], err)
                }</span>

                <span class="cov8" title="1">var generiqueType string

                switch fields[3] </span>{
                case "0":<span class="cov8" title="1">
                        generiqueType = "Princeps"</span>
                case "1":<span class="cov0" title="0">
                        generiqueType = "Générique"</span>
                case "2":<span class="cov0" title="0">
                        generiqueType = "Génériques par complémentarité posologique"</span>
                case "3":<span class="cov0" title="0">
                        generiqueType = "Générique substitutable"</span>
                }

                <span class="cov8" title="1">medsType[cis] = generiqueType</span>
        }

        <span class="cov8" title="1">return medsType, nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
